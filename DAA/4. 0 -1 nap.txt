#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Recursive + Memoization (DP)
int knapsackDP(int index, int capacity, vector<int> &value, vector<int> &weight, vector<vector<int>> &dp) {
    if (index >= value.size() || capacity == 0)
        return 0;

    // If already computed
    if (dp[index][capacity] != -1)
        return dp[index][capacity];

    // If item is too heavy → skip it
    if (weight[index] > capacity)
        return dp[index][capacity] = knapsackDP(index + 1, capacity, value, weight, dp);

    // Include and Exclude
    int include = value[index] + knapsackDP(index + 1, capacity - weight[index], value, weight, dp);
    int exclude = knapsackDP(index + 1, capacity, value, weight, dp);

    // Store and return best
    return dp[index][capacity] = max(include, exclude);
}

int main() {
    int n;
    cout << "Enter number of items: ";
    cin >> n;

    vector<int> value(n), weight(n);

    cout << "Enter values of items:\n";
    for (int i = 0; i < n; i++)
        cin >> value[i];

    cout << "Enter weights of items:\n";
    for (int i = 0; i < n; i++)
        cin >> weight[i];

    int capacity;
    cout << "Enter capacity of knapsack: ";
    cin >> capacity;

    // DP table (n+1) × (capacity+1), initialized with -1
    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, -1));

    int maxValue = knapsackDP(0, capacity, value, weight, dp);

    cout << "\nMaximum value in 0-1 Knapsack (DP Optimized) = " << maxValue << endl;
    cout << "Time Complexity: O(n * capacity)\n";
    cout << "Space Complexity: O(n * capacity)\n";

    return 0;
}
